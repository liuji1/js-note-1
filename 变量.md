一、变量的类型
　　Javascript和Java、C这些语言不同，它是一种无类型、弱检测的语言。
　　它对变量的定义并不需要声明变量类型，我们只要通过赋值的形式，可以将各种类型的数据赋值给同一个变量。例如：
　　
　　'''javascript
　　//code...
　　i = 100;//number类型
　　i = "char";//string类型
　　i={x:4};//Object类型
　　i=[1,2,3];//Array类型
　　'''
二、变量的声明
　　JS中变量申明分显式申明和隐式申明。
　　var i=100;//显式申明
　　i=100;//隐式申明
　　
三、全局变量和局部变量 
　　当JS解析器执行时，首先就会在执行环境里构建一个全局对象，我们定义的全局属性就是做为该对象的属性读取，
　　在顶层代码中我们使用this关键字和window对象都可以访问到它。而函数体中的局部变量只在函数执行时生成的调用对象中存在，
　　函数执行完毕时局部变量即刻销毁。因此在程序设计中我们需要考虑如何合理声明变量，
　　这样既减小了不必要的内存开销，同时能很大程度地避免变量重复定义而覆盖先前定义的变量所造成的Debug麻烦。
　　
　　例1：(错误)
　　    '''javascript
　　    //code...
        function square(num){   
            total=num*num; //这是操作全局变量。   
            return total;   
        }   
       val total=50;   
       val number=square(20);   
       alert(total);//total的值变成了400。
        '''
    例2：(正确)
        '''javascript
        //code...
        function square(num){   
        var total=num*num;    
        return total;   
        }
        '''
　　
四、变量作用域 
　　任何程序语言中变量的作用域都是一个很关键的细节。
　　JS中变量的作用域相对与JAVA、C这类语言显得更自由，一个很大的特征就是JS变量没有块级作用域，函数中的变量在整个函数都中有效.
　　
　　例：
　　    '''javascript
　　    //code...
        <SCRIPT LANGUAGE="JavaScript" type="text/javascript"> 
        //定义一个输出函数 
        function outPut(s){ 
        document.writeln(s) 
        } 
        //全局变量 
        var i=0; 
        //定义外部函数 
        function outer(){ 
        //访问全局变量 
        outPut(i); // 0 
        //定义一个类部函数 
        function inner(){ 
        //定义局部变量 
        var i = 1; 
        // i=1; 如果用隐式申明　那么就覆盖了全局变量i 
        outPut(i); //1 
        } 
        inner(); 
        outPut(i); //0 
        } 
        outer(); 
        </SCRIPT>
        '''
        
五、基本类型和引用类型 
　　JS不同于JAVA、C这些语言，在变量申明时并不需要声明变量的存储空间。
　　变量中所存储的数据可以分为两类：基本类型和引用类型。
　　其中数值、布尔值、null和undefined属于基本类型，对象、数组和函数属于引用类型。 
　　基本类型在内存中具有固定的内存大小。例如：数值型在内存中占有八个字节，布尔值只占有一个字节。
　　对于引用型数据，他们可以具有任意长度，因此他们的内存大小是不定的，因此变量中存储的实际上是对此数据的引用，
　　通常是内存地址或者指针，通过它们我们可以找到这个数据。 
　　 
　　 例：
　　    '''javascript
　　    //code...
　　    <SCRIPT LANGUAGE="JavaScript" type="text/javascript"> 
        //定义一个输出函数 
        function outPut(s){ 
        document.writeln(s) 
        } 
        var a = 3; 
        var b = a; 
        outPut(b); 
        //3 
        a = 4; 
        outPut(a); 
        //4 
        outPut(b); 
        //3 
        </SCRIPT>
        '''
    对基本类型b进行赋值时，实际上是又开辟了一块内存空间，因此改变变量a的值对变量b没有任何影响。 
    
    例：
        '''javascript
        //code...
        <SCRIPT LANGUAGE="JavaScript" type="text/javascript"> 
        //定义一个输出函数 
        function outPut(s){ 
        document.writeln(s) 
        } 
        var a_array = [1,2,3]; 
        var b_array = a_array; 
        outPut(b_array); //1,2,3 
        a_array[3] = 4; 
        outPut(b_array);//1,2,3,4 
        </SCRIPT>
        '''
   上面是对引用类型的变量赋值，实际上他们传递的是对内存地址的引用，因此对a_array和b_array的存取，实际上都是操作的同一块内存区域。
   如果希望重新分配内存空间存储引用型变量，那么我就需要使用克隆方法或者自定义方法来复制引用变量的数据。
   
   例：
        '''javascript
        <script language ="javascript" type ="text/javascript" > 
        var a = "change"; 
        function fun() { 
        alert(a);//输出undefined 
        var a = "改变了"; 
        alert(a);//输出改变了 
        } 
        alert(a);//输出change 
        fun(); 
        </script>
        '''
    
    var定义的是一个作用域上的变量，在第一次输出a之前，JS在预编译分析中已经将a赋值为change，
    所以第一次输出change，当调用到fun()函数的时候，JS创建一个新的作用域，
    在输出a之前，初始化所有var变量的值为undefined，所以fun()中第一次输出的是undefined，第二次输出已经给a赋值了，
    所以输出新的值；两个a在函数里面和外面是不同的两个变量
    
    例：
        '''javascript
        <script language ="javascript" type ="text/javascript" > 
        var b; 
        function fun() { 
        b = "change"; 
        } 
        alert(b);//输出undefined 
        </script>
        '''
    变量b在函数外面已经定义了，在函数中有给b赋值，但输出的却是undefined。
   
